% Global Variables

% no. of servers
map MaxServer: Pos;
eqn MaxServer = 1;

% max no. of client requests
map MaxClientRequest: Pos;
eqn MaxClientRequest = 1;

%max no. of terms
map MaxTerm: Pos;
eqn MaxTerm = 1;

% no. that defines the majority within the cluster 
% we don't model changes in cluster membership so this no. remains constant
map MAJORITY: Pos;
eqn MAJORITY = 1;

% possible states of a node
sort NodeState = struct Leader | Candidate | Follower;

% possible types of message
sort mType = struct MTreqVote | MTreqVoteResponse | MTappendEntriesReq | MTappendEntriesResponse;

% structure for different kinds of messages
sort RPC = struct RequestVote(currentTerm: Nat, lastLogIndex: Nat, lastLogTerm: Nat) | ResponseVote(currentTerm: Nat, isVoteGranted: Bool) | 
        AppendEntriesReq(currentTerm: Nat, prevLogIndex: Nat, prevLogTerm: Nat, entries: entryList, leaderCommit: Nat) | 
        AppendEntriesResponse(currentTerm: Nat, success: Bool, matchIndex: Nat);

% entry (command) inside the log
sort logCommand = struct Command(term: Nat, commandID: Nat);

% log maitained on each node (list of commands)
sort entryList = List(logCommand);

% gets the term of the last command in the log
map lastTerm: entryList -> Nat;
var log: entryList;
eqn (# log == 0) -> lastTerm(log) = 0;
    (# log != 0) -> lastTerm(log) = term(rhead(log));

% get term of a particular index of the log
% term of index 0 is 0 because log is one-indexed 
map getTerm: entryList # Nat -> Nat;
var log: entryList;
    index: Nat;
eqn (index > 0) -> getTerm(log, index) = term(log . index);
    (index == 0) -> getTerm(log, index) = 0;

% slice a log (inclusive of first and last)
map listSlice: entryList # entryList # Nat # Nat -> entryList;
var log, slice: entryList;
    first, last: Nat; 
eqn (first == 0) -> listSlice(log, slice, first, last) = listSlice(log, slice, 1, last);
    (first == min(last, # log)) -> listSlice(log, slice, first, last) = slice <| (log . min(last, # log));
    (first != min(last, # log)) ->  listSlice(log, slice, first, last) = listSlice(log, slice <| (log . first), first + 1, min(last, # log));

map listSliceNat: List(Nat) # List(Nat) # Nat # Nat -> List(Nat);
var list, slicedList: List(Nat);
    firstElement, lastElement: Nat; 
eqn (firstElement == lastElement) -> listSliceNat(list, slicedList, firstElement, lastElement) = slicedList <| (list . lastElement);
    (firstElement != lastElement) ->  listSliceNat(list, slicedList, firstElement, lastElement) = listSliceNat(list, slicedList <| (list . firstElement), firstElement + 1, lastElement);

map MajorityAgree: Nat # Nat # Nat # List(Nat) -> Nat;
var index, agreementNo, loopCounter: Nat;
    array: List(Nat);
eqn (loopCounter == MaxServer) -> MajorityAgree(index, agreementNo, loopCounter, array) = agreementNo;
    (index <= array . loopCounter) -> MajorityAgree(index, agreementNo, loopCounter, array)  = MajorityAgree(index, agreementNo + 1, loopCounter + 1, array);
    (index > array . loopCounter) -> MajorityAgree(index, agreementNo, loopCounter, array)  = MajorityAgree(index, agreementNo, loopCounter + 1, array);  

map MaxAgreeIndex: Nat # List(Nat) -> Nat;
var index: Nat;
    array: List(Nat);
eqn (index == 0) -> MaxAgreeIndex(index, array) = 0;
    (MajorityAgree(index, 1, 0, array) >= MAJORITY) -> MaxAgreeIndex(index, array) = index;
    (MajorityAgree(index, 1, 0, array) < MAJORITY) -> MaxAgreeIndex(index, array) = MaxAgreeIndex(Int2Nat(index - 1), array);

map add: List(Nat) # Nat -> List(Nat);
var listVotes: List(Nat);
    voter: Nat;
eqn (voter in listVotes) -> add(listVotes, voter) = listVotes;
    (!(voter in listVotes)) -> add(listVotes, voter) = listVotes <| voter;

%change this according to number of servers
map initArray: Nat -> List(Nat);
var num: Nat;
eqn initArray(num) = [num];
% actions 

% client interaction
act sendClientRequest, recvClientRequest: Pos # Pos;

% send RPCs
% send to, RPC, message type, sent from
act sendAppendEntriesRequest, receiveAppendEntriesRequest, appendEntryRequest, sendAppendEntriesResponse, receiveAppendEntriesResponse, appendEntryResponse, sendRequestVoteRequest, receiveRequestVote, RequestVoteMulti, sendRequestVoteResponse, receiveRequestVoteResponse, VoteResponse: Nat # RPC # mType # Nat;
% act broadcastMessage: simpleMessage;
act advanceCommitIndex, leaderTransition, candidateTransition;

proc Node(id: Nat, currentState: NodeState, currentTermNode: Nat, log: entryList, commitIndex: Nat,
          votedFor: Int, votesGranted: List(Nat), nextIndex: List(Nat), matchingIndex: List(Nat)) = 
     % Leader can receive messages from a client or broadcast messages to other nodes
     (currentState == Leader) -> (
          (sum msgID, clientCommandID: Pos . ( (id == msgID) -> recvClientRequest(clientCommandID, msgID)) . Node(log = log <| Command(currentTermNode, clientCommandID)))
          +
          (sum receiverID: Nat . ( ((receiverID != id) && (receiverID <= MaxServer)) -> 
                    (sendAppendEntriesRequest(receiverID, AppendEntriesReq(currentTermNode, Int2Nat((nextIndex . receiverID) - 1), getTerm(log, Int2Nat((nextIndex . receiverID) - 1)), listSlice(log, [], nextIndex . receiverID, min(#log, nextIndex . receiverID)), commitIndex), MTappendEntriesReq, id)) 
               )
          ) . Node()
          +
          %receive responses for append entry messages
          (sum senderID, receiverID: Nat, appendEntryRes: RPC, msgType: mType . ( ((senderID != id) && (senderID <= MaxServer) && (msgType == MTappendEntriesResponse) && (receiverID == id)) ->
                    receiveAppendEntriesResponse(receiverID, appendEntryRes, msgType, senderID) . (
                         % drop stale message
                         (currentTerm(appendEntryRes) < currentTermNode) -> Node()   
                         +
                         (currentTerm(appendEntryRes) > currentTermNode) -> Node(currentTermNode = currentTerm(appendEntryRes), currentState = Follower, votedFor = -1)
                         +
                         (currentTerm(appendEntryRes) == currentTermNode) -> (
                              (success(appendEntryRes)) -> Node(nextIndex = (listSliceNat(nextIndex, [], 0, Int2Nat(senderID-1)) ++ [matchIndex(appendEntryRes)] ++ listSliceNat(nextIndex, [], (senderID+1), Int2Nat(# nextIndex-1))))
                              <>
                              Node(nextIndex = (listSliceNat(nextIndex, [], 0, Int2Nat(senderID-1)) ++ [max(1, nextIndex . senderID)] ++ listSliceNat(nextIndex, [], (senderID+1), Int2Nat(# nextIndex-1))))
                         )
                    )
               )
          )
          +
          % advance commit index
          ((MaxAgreeIndex(# log, matchingIndex) > 0) && (getTerm(log, MaxAgreeIndex(# log, matchingIndex)) == currentTermNode)) -> advanceCommitIndex . Node(commitIndex = MaxAgreeIndex(# log, matchingIndex))  
     )
     +
     %Followers can transition into a candidate states and handle vote requests
     (currentState == Follower) -> (
          candidateTransition . Node(currentState = Candidate, currentTermNode = currentTermNode + 1, votedFor = Nat2Int(id), votesGranted = [id])
     )
     +
     % Candidates can request votes or handle vote responses
     (currentState == Candidate) -> (
          % send request vote RPCs
          (sum receiverID: Nat . (((receiverID != id) && (receiverID <= MaxServer)) -> 
                    (sendRequestVoteRequest(receiverID, RequestVote(currentTermNode, # log, getTerm(log, Int2Nat(# log - 1))), MTreqVote, id))
               )
          )
         +
          % receive request vote responses 
          (sum senderID, receiverID: Nat, voteRequestResponse: RPC, msgType: mType . ( ((senderID != id) && (senderID <= MaxServer) && (msgType == MTreqVoteResponse) && (receiverID == id)) ->
                    receiveRequestVoteResponse(receiverID, voteRequestResponse, msgType, senderID) . (
                         (currentTerm(voteRequestResponse) < currentTermNode) -> Node()
                         +
                         (currentTerm(voteRequestResponse) > currentTermNode) -> Node(currentTermNode = currentTerm(voteRequestResponse), currentState = Follower, votedFor = -1)
                         +
                         (currentTerm(voteRequestResponse) == currentTermNode) -> 
                              (isVoteGranted(voteRequestResponse)) -> Node(votesGranted = add(votesGranted, senderID)) 
                    )
               )
          )
          +
          % become leader
          (# votesGranted >= MAJORITY) -> leaderTransition . Node(currentState = Leader, nextIndex = initArray(# log + 1), matchingIndex = initArray(0))
     )
     % things all states can do
     +
     % receive request vote request RPCs
     (sum senderID, receiverID: Nat, voteRequest: RPC, msgType: mType . ( ((senderID != id) && (senderID <= MaxServer) && (msgType == MTreqVote) && (receiverID == id)) ->
               receiveRequestVote(receiverID, voteRequest, msgType, senderID) . (
                    % discard message if the term is older
                    (currentTerm(voteRequest) < currentTermNode) -> Node()
                    +
                    (                    
                         (currentTerm(voteRequest) == currentTermNode) -> 
                                   % check for validity of the log
                                   (lastLogTerm(voteRequest) >= getTerm(log, Int2Nat(# log - 1))) -> 
                                        % vote for the server if we haven't voted for anything or already voted for it
                                        (votedFor == -1 || votedFor == receiverID) -> sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, true), MTreqVoteResponse, id) . Node(votedFor = senderID)
                              % reject otherwise
                                        <>
                                        sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, false), MTreqVoteResponse, id) . Node()
                                   <>
                                   sendRequestVoteResponse(senderID, ResponseVote(currentTermNode, false), MTreqVoteResponse, id) . Node()
                    )
                    +
                    (                    
                         (currentTerm(voteRequest) > currentTermNode) -> 
                                   % check for validity of the log
                                   (lastLogTerm(voteRequest) >= getTerm(log, Int2Nat(# log - 1))) -> 
                                        % vote for the server if we haven't voted for anything or already voted for it
                                        sendRequestVoteResponse(senderID, ResponseVote(currentTerm(voteRequest), true), MTreqVoteResponse, id) . Node(currentTermNode = currentTerm(voteRequest), currentState = Follower, votedFor = senderID)
                                   % reject otherwise
                                   <>
                                   sendRequestVoteResponse(senderID, ResponseVote(currentTerm(voteRequest), false), MTreqVoteResponse, id) . Node(currentTermNode = currentTerm(voteRequest), currentState = Follower, votedFor = -1)
                    )
               )
          )
     )
     +
     % handle append entries request or heartbeat
     (sum senderID, receiverID: Nat, appendEntry: RPC, msgType: mType . ( ((senderID != id) && (senderID <= MaxServer) && (msgType == MTappendEntriesReq) && (receiverID == id)) ->
               receiveAppendEntriesRequest(receiverID, appendEntry, msgType, senderID) . (
                     % discard message if the term is older
                    (currentTerm(appendEntry) < currentTermNode) -> Node()
                    +
                    (
                         (currentTerm(appendEntry) == currentTermNode) -> 
                              ((prevLogIndex(appendEntry) >= 0) && (prevLogIndex(appendEntry) <= # log) && (prevLogTerm(appendEntry) == getTerm(log,prevLogIndex(appendEntry)))) ->
                                   % heartbeat message
                                   (# entries(appendEntry) == 0) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry)), MTappendEntriesResponse, id) . Node(commitIndex = leaderCommit(appendEntry))
                                   <>
                                        (
                                             ((# log >= (prevLogIndex(appendEntry)+1)) && (getTerm(log, (prevLogIndex(appendEntry)+1)) != getTerm(entries(appendEntry), 1))) ->
                                                  (# log == prevLogIndex(appendEntry)) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(log = listSlice(log, [], 1, prevLogIndex(appendEntry)) ++ entries(appendEntry), commitIndex = leaderCommit(appendEntry))
                                                  <>
                                                  sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(log = listSlice(log, [], 1, prevLogIndex(appendEntry)), commitIndex = leaderCommit(appendEntry))
                                             <>
                                             sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTermNode, true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(commitIndex = leaderCommit(appendEntry))
                                        )

                    )
                    +
                    %if the append entry request has higher term then update our term
                    (
                         (currentTerm(appendEntry) == currentTermNode) -> 
                              ((prevLogIndex(appendEntry) >= 0) && (prevLogIndex(appendEntry) <= # log) && (prevLogTerm(appendEntry) == getTerm(log,prevLogIndex(appendEntry)))) ->
                                   % heartbeat message
                                   (# entries(appendEntry) == 0) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry)), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, commitIndex = leaderCommit(appendEntry))
                                   <>
                                        (
                                             ((# log >= (prevLogIndex(appendEntry)+1)) && (getTerm(log, (prevLogIndex(appendEntry)+1)) != getTerm(entries(appendEntry), 1))) ->
                                                  (# log == prevLogIndex(appendEntry)) -> sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, log = listSlice(log, [], 1, prevLogIndex(appendEntry)) ++ entries(appendEntry), commitIndex = leaderCommit(appendEntry))
                                                  <>
                                                  sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, log = listSlice(log, [], 1, prevLogIndex(appendEntry)), commitIndex = leaderCommit(appendEntry))
                                             <>
                                             sendAppendEntriesResponse(senderID, AppendEntriesResponse(currentTerm(appendEntry), true, prevLogIndex(appendEntry) + 1), MTappendEntriesResponse, id) . Node(currentTermNode = currentTerm(appendEntry), currentState = Follower, votedFor = -1, commitIndex = leaderCommit(appendEntry))
                                        )

                    )
               )
          )
     )
     ;

proc Client(clientCommandID: Pos) = 
     sum serverID: Pos . ((clientCommandID <= MaxClientRequest) -> sendClientRequest(clientCommandID, serverID) . Client(clientCommandID+1));

init allow( {appendEntryRequest, appendEntryResponse, RequestVoteMulti, VoteResponse},
               comm(
                    {
                         sendAppendEntriesRequest | receiveAppendEntriesRequest -> appendEntryRequest, 
                         sendAppendEntriesResponse | receiveAppendEntriesResponse -> appendEntryResponse, 
                         sendRequestVoteRequest | receiveRequestVote -> RequestVoteMulti, 
                         sendRequestVoteResponse | receiveRequestVoteResponse -> VoteResponse

                    },
                    Client(1) || Node(id = 0, currentState = Follower, currentTermNode = 0, log = [], commitIndex = 0,
          votedFor = -1, votesGranted = [], nextIndex = initArray(0), matchingIndex = initArray(0))
               )

);